package package3{		// ^^_^^^        public class P3Class1 implements P3Iterface3        {                private static const _InvSbox:Array;                private static const _Sbox:Array;                private static const _Xtime2:Array;                private static const _Xtime2Sbox:Array;                private static const _Xtime3Sbox:Array;                private static const _Xtime9:Array;                private static const _XtimeB:Array;                private static const _XtimeD:Array;                private static const _XtimeE:Array;                private static const Nb:uint = 4;                private static var _Rcon:Array;                private static var i:uint;                private static var InvSbox:flash.utils.ByteArray;                private static var Rcon:flash.utils.ByteArray;                private static var Sbox:flash.utils.ByteArray;                private static var Xtime2:flash.utils.ByteArray;                private static var Xtime2Sbox:flash.utils.ByteArray;                private static var Xtime3Sbox:flash.utils.ByteArray;                private static var Xtime9:flash.utils.ByteArray;                private static var XtimeB:flash.utils.ByteArray;                private static var XtimeD:flash.utils.ByteArray;                private static var XtimeE:flash.utils.ByteArray;                public function P3Class1(arg0:flash.utils.ByteArray)                {                        tmp = new flash.utils.ByteArray();                        state = new flash.utils.ByteArray();                        keyLength = arg0.length;                        this.key = new flash.utils.ByteArray();                        this.key.writeBytes(arg0);                        expandKey();                }                private var key:flash.utils.ByteArray;                private var keyLength:uint;                private var Nr:uint;                private var state:flash.utils.ByteArray;                private var tmp:flash.utils.ByteArray;                public function ;;^^;;;(arg0:flash.utils.ByteArray, arg1:uint):void                {                        var uint1:uint = 0;                        state.position = 0;                        state.writeBytes(arg0, arg1, Nb * 4);                        addRoundKey(key, 0);                        uint1 = 1;                        while(uint1 < Nr + 1)                        {                                if(uint1 < Nr)                                {                                        mixSubColumns();                                }                                else                                {                                        shiftRows();                                }                                addRoundKey(key, (uint1 * Nb) * 4);                                uint1 = uint1 + 1;                        }                        arg0.position = arg1;                        arg0.writeBytes(state);                }                public function ;^^;;;;(arg0:flash.utils.ByteArray, arg1:uint):void                {                        var uint1:uint = 0;                        state.position = 0;                        state.writeBytes(arg0, arg1, Nb * 4);                        addRoundKey(key, (Nr * Nb) * 4);                        invShiftRows();                        uint1 = Nr;                        uint1 = Number(uint1) - 1;                        if(Number(uint1))                        {                                addRoundKey(key, (uint1 * Nb) * 4);                                if(uint1)                                {                                        invMixSubColumns();                                }                        }                        else                        {                                arg0.position = arg1;                                arg0.writeBytes(state);                        }                }                public function dispose():void                {                        var uint1:uint = 0;                        var local1:* = package2.P2Class1(null);                        local1 = package2.P2Class1(new package2.P2Class1());                        uint1 = 0;                        while(uint1 < key.length)                        {                                key[uint1] = local1.nextByte();                                uint1 = uint1 + 1;                        }                        Nr = local1.nextByte();                        uint1 = 0;                        while(uint1 < state.length)                        {                                state[uint1] = local1.nextByte();                                uint1 = uint1 + 1;                        }                        uint1 = 0;                        while(uint1 < tmp.length)                        {                                tmp[uint1] = local1.nextByte();                                uint1 = uint1 + 1;                        }                        key.length = 0;                        keyLength = 0;                        state.length = 0;                        tmp.length = 0;                        key = null;                        state = null;                        tmp = null;                        Nr = 0;                        package1.Memory.gc();                }                public function getBlockSize():uint                {                        return 16;                }                public function toString():String                {                        return ('aes') + (8 * keyLength);                }                protected function addRoundKey(arg0:flash.utils.ByteArray, arg1:uint):void                {                        var uint1:uint = 0;                        uint1 = 0;                        while(uint1 < 16)                        {                                state[uint1] = (state[uint1]) ^ (arg0[uint1 + arg1]);                                uint1 = uint1 + 1;                        }                }                protected function invMixSubColumns():void                {                        var uint1:uint = 0;                        tmp.length = 0;                        tmp[0] = (((XtimeE[state[0]]) ^ (XtimeB[state[1]])) ^ (XtimeD[state[2]])) ^ (Xtime9[state[3]]);                        tmp[5] = (((Xtime9[state[0]]) ^ (XtimeE[state[1]])) ^ (XtimeB[state[2]])) ^ (XtimeD[state[3]]);                        tmp[10] = (((XtimeD[state[0]]) ^ (Xtime9[state[1]])) ^ (XtimeE[state[2]])) ^ (XtimeB[state[3]]);                        tmp[15] = (((XtimeB[state[0]]) ^ (XtimeD[state[1]])) ^ (Xtime9[state[2]])) ^ (XtimeE[state[3]]);                        tmp[4] = (((XtimeE[state[4]]) ^ (XtimeB[state[5]])) ^ (XtimeD[state[6]])) ^ (Xtime9[state[7]]);                        tmp[9] = (((Xtime9[state[4]]) ^ (XtimeE[state[5]])) ^ (XtimeB[state[6]])) ^ (XtimeD[state[7]]);                        tmp[14] = (((XtimeD[state[4]]) ^ (Xtime9[state[5]])) ^ (XtimeE[state[6]])) ^ (XtimeB[state[7]]);                        tmp[3] = (((XtimeB[state[4]]) ^ (XtimeD[state[5]])) ^ (Xtime9[state[6]])) ^ (XtimeE[state[7]]);                        tmp[8] = (((XtimeE[state[8]]) ^ (XtimeB[state[9]])) ^ (XtimeD[state[10]])) ^ (Xtime9[state[11]]);                        tmp[13] = (((Xtime9[state[8]]) ^ (XtimeE[state[9]])) ^ (XtimeB[state[10]])) ^ (XtimeD[state[11]]);                        tmp[2] = (((XtimeD[state[8]]) ^ (Xtime9[state[9]])) ^ (XtimeE[state[10]])) ^ (XtimeB[state[11]]);                        tmp[7] = (((XtimeB[state[8]]) ^ (XtimeD[state[9]])) ^ (Xtime9[state[10]])) ^ (XtimeE[state[11]]);                        tmp[12] = (((XtimeE[state[12]]) ^ (XtimeB[state[13]])) ^ (XtimeD[state[14]])) ^ (Xtime9[state[15]]);                        tmp[1] = (((Xtime9[state[12]]) ^ (XtimeE[state[13]])) ^ (XtimeB[state[14]])) ^ (XtimeD[state[15]]);                        tmp[6] = (((XtimeD[state[12]]) ^ (Xtime9[state[13]])) ^ (XtimeE[state[14]])) ^ (XtimeB[state[15]]);                        tmp[11] = (((XtimeB[state[12]]) ^ (XtimeD[state[13]])) ^ (Xtime9[state[14]])) ^ (XtimeE[state[15]]);                        uint1 = 0;                        while(uint1 < 4 * Nb)                        {                                state[uint1] = InvSbox[tmp[uint1]];                                uint1 = uint1 + 1;                        }                }                protected function invShiftRows():void                {                        var uint1:uint = 0;                        state[0] = InvSbox[state[0]];                        state[4] = InvSbox[state[4]];                        state[8] = InvSbox[state[8]];                        state[12] = InvSbox[state[12]];                        uint1 = InvSbox[state[13]];                        state[13] = InvSbox[state[9]];                        state[9] = InvSbox[state[5]];                        state[5] = InvSbox[state[1]];                        state[1] = uint1;                        uint1 = InvSbox[state[2]];                        state[2] = InvSbox[state[10]];                        state[10] = uint1;                        uint1 = InvSbox[state[6]];                        state[6] = InvSbox[state[14]];                        state[14] = uint1;                        uint1 = InvSbox[state[3]];                        state[3] = InvSbox[state[7]];                        state[7] = InvSbox[state[11]];                        state[11] = InvSbox[state[15]];                        state[15] = uint1;                }                protected function mixSubColumns():void                {                        tmp.length = 0;                        tmp[0] = (((Xtime2Sbox[state[0]]) ^ (Xtime3Sbox[state[5]])) ^ (Sbox[state[10]])) ^ (Sbox[state[15]]);                        tmp[1] = (((Sbox[state[0]]) ^ (Xtime2Sbox[state[5]])) ^ (Xtime3Sbox[state[10]])) ^ (Sbox[state[15]]);                        tmp[2] = (((Sbox[state[0]]) ^ (Sbox[state[5]])) ^ (Xtime2Sbox[state[10]])) ^ (Xtime3Sbox[state[15]]);                        tmp[3] = (((Xtime3Sbox[state[0]]) ^ (Sbox[state[5]])) ^ (Sbox[state[10]])) ^ (Xtime2Sbox[state[15]]);                        tmp[4] = (((Xtime2Sbox[state[4]]) ^ (Xtime3Sbox[state[9]])) ^ (Sbox[state[14]])) ^ (Sbox[state[3]]);                        tmp[5] = (((Sbox[state[4]]) ^ (Xtime2Sbox[state[9]])) ^ (Xtime3Sbox[state[14]])) ^ (Sbox[state[3]]);                        tmp[6] = (((Sbox[state[4]]) ^ (Sbox[state[9]])) ^ (Xtime2Sbox[state[14]])) ^ (Xtime3Sbox[state[3]]);                        tmp[7] = (((Xtime3Sbox[state[4]]) ^ (Sbox[state[9]])) ^ (Sbox[state[14]])) ^ (Xtime2Sbox[state[3]]);                        tmp[8] = (((Xtime2Sbox[state[8]]) ^ (Xtime3Sbox[state[13]])) ^ (Sbox[state[2]])) ^ (Sbox[state[7]]);                        tmp[9] = (((Sbox[state[8]]) ^ (Xtime2Sbox[state[13]])) ^ (Xtime3Sbox[state[2]])) ^ (Sbox[state[7]]);                        tmp[10] = (((Sbox[state[8]]) ^ (Sbox[state[13]])) ^ (Xtime2Sbox[state[2]])) ^ (Xtime3Sbox[state[7]]);                        tmp[11] = (((Xtime3Sbox[state[8]]) ^ (Sbox[state[13]])) ^ (Sbox[state[2]])) ^ (Xtime2Sbox[state[7]]);                        tmp[12] = (((Xtime2Sbox[state[12]]) ^ (Xtime3Sbox[state[1]])) ^ (Sbox[state[6]])) ^ (Sbox[state[11]]);                        tmp[13] = (((Sbox[state[12]]) ^ (Xtime2Sbox[state[1]])) ^ (Xtime3Sbox[state[6]])) ^ (Sbox[state[11]]);                        tmp[14] = (((Sbox[state[12]]) ^ (Sbox[state[1]])) ^ (Xtime2Sbox[state[6]])) ^ (Xtime3Sbox[state[11]]);                        tmp[15] = (((Xtime3Sbox[state[12]]) ^ (Sbox[state[1]])) ^ (Sbox[state[6]])) ^ (Xtime2Sbox[state[11]]);                        state.position = 0;                        state.writeBytes(tmp, 0, Nb * 4);                }                protected function shiftRows():void                {                        var uint1:uint = 0;                        state[0] = Sbox[state[0]];                        state[4] = Sbox[state[4]];                        state[8] = Sbox[state[8]];                        state[12] = Sbox[state[12]];                        uint1 = Sbox[state[1]];                        state[1] = Sbox[state[5]];                        state[5] = Sbox[state[9]];                        state[9] = Sbox[state[13]];                        state[13] = uint1;                        uint1 = Sbox[state[2]];                        state[2] = Sbox[state[10]];                        state[10] = uint1;                        uint1 = Sbox[state[6]];                        state[6] = Sbox[state[14]];                        state[14] = uint1;                        uint1 = Sbox[state[15]];                        state[15] = Sbox[state[11]];                        state[11] = Sbox[state[7]];                        state[7] = Sbox[state[3]];                        state[3] = uint1;                }                private function expandKey():void                {                        var uint1:uint = 0;                        var uint2:uint = 0;                        var uint3:uint = 0;                        var uint4:uint = 0;                        var uint5:uint = 0;                        var uint6:uint = 0;                        var uint7:uint = 0;                        uint7 = key.length / 4;                        Nr = uint7 + 6;                        uint6 = uint7;                        while(uint6 < Nb * (Nr + 1))                        {                                uint1 = key[(4 * uint6) - 4];                                uint2 = key[(4 * uint6) - 3];                                uint3 = key[(4 * uint6) - 2];                                uint4 = key[4 * uint6 - 1];                                if(uint6 % uint7)                                {                                        if(uint7 > 6)                                        {                                                if(4 == (uint6 % uint7))                                                {                                                        uint1 = Sbox[uint1];                                                        uint2 = Sbox[uint2];                                                        uint3 = Sbox[uint3];                                                        uint4 = Sbox[uint4];                                                }                                        }                                        else                                        {                                                uint1 = Sbox[uint1];                                                uint2 = Sbox[uint2];                                                uint3 = Sbox[uint3];                                                uint4 = Sbox[uint4];                                        }                                }                                else                                {                                        uint5 = uint4;                                        uint4 = Sbox[uint1];                                        uint1 = (Sbox[uint2]) ^ (Rcon[uint6 / uint7]);                                        uint2 = Sbox[uint3];                                        uint3 = Sbox[uint5];                                }                                key[(4 * uint6) + 0] = (key[((4 * uint6) - (4 * uint7)) + 0]) ^ uint1;                                key[(4 * uint6) + 1] = (key[((4 * uint6) - (4 * uint7)) + 1]) ^ uint2;                                key[(4 * uint6) + 2] = (key[((4 * uint6) - (4 * uint7)) + 2]) ^ uint3;                                key[(4 * uint6) + 3] = (key[((4 * uint6) - (4 * uint7)) + 3]) ^ uint4;                                uint6 = uint6 + 1;                        }                }        }}